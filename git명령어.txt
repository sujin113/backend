협업 시에는 항상 pull하고 push하기 안그러면 충돌

git clone https://github.com/sujin113/Git-Tutorial.git
git commit -m "Add Text File [document.txt]"
git push (-f: 강제옵션)
git status
git  add update.txt
git reset update.txt
git status
git add update.txt
git status
update.txt 내용 수정
git status
git commit
git push
수정된 내용이 git에 올라감.

git log
:는 더 많은 내용을 보여줌. enter로 보면됨.
다 보고 나서는 q로 퇴장 

git reset --hard log 해시 
이 log 전은 다 지워지고 이때로 돌아감(로컬에만)
git push -f 강제 푸쉬 로컬과 원격이 같아짐
 
git add .
git commit -m ""
git push
git commit --amend
커밋 메시지 수정
:wq!

git branch
git branch add develop
git branch
git checkout develop
test.txt 수정
git add .
git commit -m "test.txt [branch]"
git log
마스터에서 수행한 일과 디벨롭에서 수행한  작업이 달라 merge해야함
git checkout master
git merge develop
git log
git push
git branch -d develop 
병합이 끝나면 브랜치는 삭제
git branch
git branch add develop
git branch
git checkout develop
git branch
test.txt 수정
git add . 
git commit -m ""
git log
git checkout master
test.txt 수정
git add .
git commit -m "'
git log
git checkout develop
git log
git checkout master
git merge develop
test.txt가 달라 충돌발생
<<<<<<< HEAD
study merge //crush test
=======
study merge
>>>>>>> develop
헤드는 마스터. 이렇게 직접 충돌부분을 보여준다
원하는대로 수정
git  add . 
git commit -m ""
git merge develop
git log (master와 branch log를 한 번에 보여줌)
git push
git remote show origin : origin 내용 모두 볼 수 있음
git remote add 원격저장소
git log origin/master
git remote -v
git remote rm 원격저장소 : 원격저장소 삭제 
git remote -v

=====================

Chapter 1 - 시작하기



1.yum install git-core

2.git --version



# 주요 명령어

$ clear : Bash 초기화

$ pwd : 현재 경로

$ cd ~ : home 이동

$ mkdir * : 경로 생성

$ ls -al : 경로 조회

$ git init : 현재 경로 저장소 생성

$ git status : 경로 저장소 상태

$ git add * : 파일 추적 추가 -> Staged (커밋 대기 상태)

$ git mv * : 파일 이름 변경

$ git rm * : 파일 삭제

$ git commit : 추적 파일 커밋

$ git log : 저장소 로그, 버전 정보 기록 ->  q 나가기



# 주요 용어

Staging area : 커밋 대기 파일들이 가는 곳

Repository : 커밋이 된 결과가 저장되는 곳



# 파일 상태 3가지

@ Committed란 데이터가 로컬 데이터베이스에 안전하게 저장됐다는 것을 의미

@ Modified는 수정한 파일을 아직 로컬 데이터베이스에 커밋하지 않은 것

@ Staged란 현재 수정한 파일을 곧 커밋할 것이라고 표시한 상태를 의미



# 최초 설정

$ git config --global user.name "닉네임" : 버전 정보 - 최초 1회 등록

$ git config --global user.email "이메일" : 버전 정보 - 최초 1회 등록

@ 만약 프로젝트마다 다른 이름과 이메일 주소를 사용하고 싶으면 --global 옵션을 빼고 명령을 실행

$ git config --global core.editor vim

@ Git에서 사용할 기본 편집기 지정, 시스템 기본 편집기를 사용하지 않을 경우 실행

$ git config --global merge.tool vimdiff

@ Merge 충돌을 해결하기 위해 사용하는 Diff 도구 설정 가능, vimdiff를 사용 시에 위와 같이 실행

$ git config --list

@ 설정 확인, 특정 키값 확인 시에 git config user.name와 같이 입력







Chapter 2 - Git의 기초



2-1 Git 저장소 만들기



* Git 저장소를 만드는 방법은 두 가지로. 기존 프로젝트를 Git 저장소로 만드는 방법이 있고 다른 서버에 있는 저장소를 Clone하는 방법 존재



# 기존 디렉토리를 Git 저장소로 만들기

$ git init

@ 기존 프로젝트를 Git으로 관리하고 싶을 때, 프로젝트의 디렉토리로 이동해서 명령을 실행

@ 이 명령은 .git이라는 하위 디렉토리를 생성하며, .git 디렉토리에는 저장소에 필요한 뼈대 파일(Skeleton)이 존재

$ git add *.c

$ git add README

$ git commit -m 'initial project version'

@ Git이 파일을 관리하게 하려면 저장소에 git add 명령으로 파일을 추가하고 커밋



# 기존 저장소를 Clone하기

git clone git://github.com/schacon/grit.git

@ Ruby용 Git 라이브러리인 Grit으로, git clone [url] 명령으로 저장소를 Clone

@ 이 명령은 "grit"이라는 디렉토리를 만들고 그 안에 .git 디렉토리를 만들고, 저장소의 데이터를 모두 가져와서 자동으로 가장 최신 버전을 Checkout해 놓음 또한 grit 디렉토리로 이동하면 Checkout으로 생성한 파일을 볼 수 있고 당장 하고자 하는 일을 시작 가능

git clone git://github.com/schacon/grit.git mygrit

@ 디렉토리 이름이 mygrit이라는 것만 빼면 이 명령의 결과와 앞선 명령의 결과는 동일





2-2 수정하고 저장소에 저장하기



# 파일의 상태 확인하기

$ git status

@ 현재 작업중인 브랜치와 상태 출력, 기본 브랜치는 master



# 파일을 새로 추적하기

$ git add README

$ git status 명령을 다시 실행하면 README 파일이 Tracked 상태이면서 Staged 상태라는 것을 확인

$ git add 명령은 파일 또는 디렉토리의 경로명을 아규먼트로 받으며 만일 디렉토리를 아규먼트로 줄 경우, 그 디렉토리 아래에 있는 모든 파일들을 재귀적으로 추가



# Modified 상태의 파일을 Stage하기

@ Staged 상태의 파일을 수정 후 $ git status 명령어로 입력하면 Tracked 상태에 Modified로 변경됌

@ 커밋에 반영하기 위해서 다시 $ git add로 재추적



# 파일 무시하기



* 어떤 파일은 Git이 자동으로 추가하거나 Untracked 파일이라고 보여줄 필요가 없다. 보통 로그 파일이나 빌드 시스템이 자동으로 생성한 파일이 그러하며, 그런 파일을 무시하려면 .gitignore 파일을 만들고 그 안에 무시할 파일 패턴을 작성



# Staged와 Unstaged 상태의 변경 내용을 보기

$ git diff

@ 워킹 디렉토리에 있는 것과 Staging Area에 있는 것을 비교

$ git diff --cached(staged)

@ 저장소에 커밋한 것과 Staging Area에 있는 것을 비교



# 변경사항 커밋하기

$ git add

@ 파일을 추적한 (커밋 대기한) 상태에서 사용함

$ git commit

@ Git 설정에 지정된 편집기가 실행되며, 입력 (i) 첫 줄에 메시지 작성하고 저장 후 종료 (ESC 및 :wq)

$ git commit -m "Initial project version"

@ 메세지 인라인 첨부

$ git commit -v

@ 편집기에 diff 메시지 추가



# Staging Area 생략하기

$ git commit -a

@ -Tracked 상태의 파일을 자동으로 Staging Area에 넣으므로 $ git add 명령어 생략 가능



# 파일을 삭제하기

$ git rm README.txt

@ rm 옵션은 Tracked 상태의 파일을 삭제하고(정확하게는 Staging Area에서 삭제하는 것), 워킹 디렉토리에 있는 파일도 삭제 -> 이미 파일을 수정했거나 Index에(역주, Staging Area을 Git Index라고도 부른다) 추가했다면 -f 옵션으로 강제 삭제, 한 번도 커밋한적 없는 데이터는 Git으로 복구할 수 없음

$ git rm --cached README.txt

@ --cached 옵션은 Staging Area에서만 제거하고 워킹 디렉토리에 있는 파일은 지우지 않고 남겨둠



# 파일 이름 변경하기



* Git은 다른 VCS 시스템과는 달리 파일 이름의 변경이나 파일의 이동을 명시적으로 관리하지 않는다. 다시 말해서 파일 이름이 변경됐다는 별도의 정보를 저장하지 않음



$ git mv README.txt README

@ 이 명령을 실행하고 Git의 상태를 확인해보면 Git은 이름이 바뀐 사실을 확인함

@ 아래의 명령어들을 수행한 것과 같음

$ mv README.txt README

$ git rm README.txt

$ git add README

@ Git으로 파일 이름 변경 추적, 추적하지 않을 경우 mv README.txt





2-3 커밋 히스토리 조회하기



# 커밋 히스토리 조회하기

$ git log

@ 저장소의 커밋 히스토리를 시간순으로 각 커밋의 SHA-1 체크섬, 저자 이름, 저자 이메일, 커밋한 날짜, 커밋 메시지를 출력

$ git log -p -2

@ -p는 각 커밋의 diff 결과를 출력, -2는 최근 두 개의 결과만 보여주는 옵션

$ git log --stat

@ 히스토리의 통계를 보여주는 옵션으로 각 커밋의 통계 정보를 조회 (어떤 파일이 수정됐는지, 얼마나 많은 파일이 변경됐는지, 또 얼마나 많은 줄을 추가하거나 삭제했는지 보여주며 요약정보는 가장 뒤쪽에 출력)



# 조회 제한조건

$ git log

@ --grep 옵션으로 커밋 메시지에서 키워드를 검색(author와 grep 옵션을 함께 사용하면 모두 만족하는 커밋을 탐색).

@ grep 옵션을 여러개 사용하면 그중 하나이상 만족하는 커밋을 탐색하며, 모두 만족하는 커밋을 찾으려면 --all-match 옵션을 추가

$ git log -- path1 path2

@ 디렉토리나 파일 이름을 사용하여 그 파일이 변경된 log의 결과를 검색

@

-(n) : 최근 n 개의 커밋만 조회

--since, --after : 명시한 날짜 이후의 커밋만 검색

--until, --before : 명시한 날짜 이전의 커밋만 조회

--author : 입력한 저자의 커밋만 출력

--committer : 입력한 커미터의 커밋만 출력

@



# GUI 도구로 히스토리를 시각화하기

@ 대표적인 Git 클라이언트 Smartgit (유료), Gitkraken (상업 유료), Sourcetree (무료)...





2-4 되돌리기



* 한 번 되돌리면 복구할 수 없음



# 커밋 수정하기

$ git commit --amend

@ 너무 일찍 커밋했거나 어떤 파일을 빼먹었을 때 그리고 커밋 메시지를 잘못 적었을 때, 다시 커밋하고 싶으면 --amend 옵션 사용

@ 이 명령은 Staging Area를 사용하여 커밋하며. 만약 마지막으로 커밋하고 나서 수정한 것이 없다면 (커밋하자마자 바로 이 명령을 실행하는 경우) 조금 전에 한 커밋과 모든 것이 같으므로, 이때는 커밋 메시지만 수정

@ 편집기가 실행되면 이전 커밋 메시지가 자동으로 포함된다. 메시지를 수정하지 않고 그대로 커밋해도 기존의 커밋을 덮음

@ 커밋을 했는데 Stage하는 것을 깜빡하고 빠트린 파일이 있으면 아래와 같이 고침

$ git commit -m 'initial commit'

$ git add forgotten_file

$ git commit --amend

@ 명령어 3개는 모두 하나의 커밋으로 기록되며, 두 번째 커밋은 첫 번째 커밋을 덮음

~



# 파일 상태를 Unstage로 변경하기

$ git reset HEAD benchmarks.rb

@ benchmarks.rb 파일을 Unstage 상태로 변경



# Modified 파일 되돌리기

$ git status

@ modified: benchmarks.rb 파일 상태 확인

$ git checkout -- benchmarks.rb

@ 수정 이전의 파일로 덮어써서 복구 - Git 1.6.1 이상 (업그레이드 권장)



* 커밋하지 않고 잃어버린 것은 절대로 되돌릴 수 없음





2-5 리모트 저장소



# 리모트 저장소 확인하기

$ git remote

@ 현재 프로젝트에 등록된 리모트 저장소를 확인 및 단축 이름을 출력 (저장소를 Clone하면 origin이라는 리모트 저장소가 자동으로 등록되기 때문에 origin이라는 이름 확인 가능)

@ -v옵션을 주어 단축이름과 URL을 함께 볼 수 있음



# 리모트 저장소 추가하기

$ git remote add [단축이름] [url]

@ ex) $ git remote add pb git://github.com/paulboone/ticgit.git

@ URL 대신에 스트링 pb를 사용 가능

$ git fetch pb

@ 로컬 저장소에는 없지만 Paul의 저장소에 있는 것을 가져올 경우 실행

@ 로컬에서 pb/master가 Paul의 master 브랜치가되며, 이것을 로컬 브랜치중 하나에 머지하거나 체크아웃하여 브랜치 내용을 자세히 확인 가능



# 리모트 저장소를 Pull 하거나 Fetch 하기

$ git fetch [remote-name]

@ 리모트 저장소에서 데이터를 가져올 경우 실행

@ 로컬에는 없지만, 리모트 저장소에는 있는 데이터를 모두 가져옴

@ 리모트 저장소의 모든 브랜치를 로컬에서 접근할 수 있어서 언제든지 머지를 하거나 내용을 살펴볼 수 있음

@ 저장소를 Clone하면 명령은 자동으로 리모트 저장소를 origin이라는 이름으로 추가하므로, 나중에 $ git fetch origin을 실행하면 Clone한 이후에(혹은 마지막으로 가져온 이후에) 수정된 것을 모두 가져옴

@ fetch 명령은 리모트 저장소의 데이터를 모두 로컬로 가져오지만, 자동으로 머지하지 않으므로, 로컬에서 하던 작업을 정리하고 나서 수동으로 머지해야함

@ $ git pull 명령으로 리모트 저장소 브랜치에서 데이터를 가져올 뿐만 아니라 자동으로 로컬 브랜치와 머지시킬 수 있음 (아래와 같다)

@ 1. $ git clone 명령은 자동으로 로컬의 master 브랜치가 리모트 저장소의 master 브랜치를 추적하도록 함 (물론 리모트 저장소에 master 브랜치가 있다고 가정에서).

@ 2. $ git pull 명령은 Clone한 서버에서 데이터를 가져오고 그 데이터를 자동으로 현재 작업하는 코드와 머지시킴



# 리모트 저장소에 Push하기

$ git push [리모트 저장소 이름] [브랜치 이름]

@ 프로젝트를 공유하고 싶을 때 리모트 저장소에 Push 사용

@ ex) $ git push origin master

@ master 브랜치를 origin 서버에 Push 실행 (Clone하면 보통 자동으로 origin 이름 생성)

@ Clone한 리모트 저장소에 쓰기 권한이 있고, Clone하고 난 이후 아무도 리모트 저장소에 Push하지 않았을 때만 사용 가능하며, Clone한 사람이 여러 명 있을 때, 다른 사람이 Push한 후에 Push하려고 하면 Push할 수 없고, 먼저 다른 사람이 작업한 것을 가져와서 머지한 후에 Push할 수 있음



# 리모트 저장소 살펴보기

$ git remote show [리모트 저장소 이름]

@ 리모트 저장소의 구체적인 정보를 확인

$ git remote show origin

@ origin 같은 단축이름 사용 가능

@ 리모트 저장소의 URL과 추적하는 브랜치를 출력, 이 명령은 $ git pull 명령을 실행할 때 master 브랜치와 머지할 브랜치가 무엇인지 출하며, $ git pull 명령은 리모트 저장소 브랜치의 데이터를 모두 가져오고 나서 자동으로 머지하고, 가져온 모든 리모트 저장소 정보도 출력

브랜치명을 생략하고 $ git push 명령을 실행할 때 어떤 브랜치가 어떤 브랜치로 Push되는지 출력되며, 아직 로컬로 가져오지 않은 리모트 저장소의 브랜치는 어떤 것들이 있는지, 서버에서는 삭제됐지만 아직 가지고 있는 브랜치는 어떤 것인지, $ git pull 명령을 실행했을 때 자동으로 머지할 브랜치 목록 출력



# 리모트 저장소 이름을 바꾸거나 리모트 저장소를 삭제하기

$ git remote rename pb paul

@ 리모트 저장소의 이름 pb를 paul로 변경

@ 리모트 저장소의 브랜치 이름도 변경되므로, 여태까지 pb/master로 리모트 저장소 브랜치를 사용했으면 이제는 paul/master라고 사용

$ git remote rm paul

@ 리모트 저장소 paul 삭제

@ 서버 정보가 바뀌었을 때, 더는 별도의 미러가 필요하지 않을 때, 더는 기여자가 활동하지 않을 경우 사용





2-6 태그



* 보통 릴리즈할 때 사용한다 (v1.0, 등등)



# 태그 조회하기

$ git tag

@ 만들어진 태그가 있는지 확인 (알파벳 순서)

$ git tag -l 'v1.4.2.*'

@ 1.4.2 버전의 태그들만 검색



# 태그 붙이기

@ Git의 태그는 Lightweight 태그와 Annotated 태그로 두 종류 존재

@ Lightweight 태그는 특정 커밋에 대한 포인터 역할을 수행

@ Annotated 태그는 Git 데이터베이스에 태그를 만든 사람의 이름, 이메일과 태그를 만든 날짜, 그리고 태그 메시지도 저장하며, GPG(GNU Privacy Guard)로 서명할 수도 있으므로, 이 모든 정보를 저장해둬야 할 때에만 Annotated 태그를 추천



# Annotated 태그

$ $ git tag -a v1.4 -m 'my version 1.4'

@ -m 옵션으로 태그를 저장할 때 메시지를 함께 저장할 수 있으나, 명령을 실행할 때 메시지를 입력하지 않으면 Git은 편집기를 실행

@ $ git show 명령으로 태그 정보와 커밋 정보를 모두 확인 가능



# 태그에 서명하기

$ git tag -s v1.5 -m 'my signed 1.5 tag'

@ GPG 개인키가 있으면 태그에 서명할 수 있다. 이때에는 -a옵션 대신 -s를 사용

@ 이 태그에 $ git show v1.5를 실행하면 GPG 서명도 확인 가능



# Lightweight 태그

$ git tag v1.4-lw

@ 기본적으로 파일에 커밋 체크섬을 저장하며, 다른 정보는 저장하지 않으므로 -a, -s, -m 옵션을 사용하지 않음

@ 이 태그에 $ git show v1.4-lw를 실행하면 별도의 태그 정보를 확인할 수 없으며, 단순히 커밋 정보만을 출력



# 태그 검증하기

$ git tag -v v1.4.2.1

@ git tag -v [태그 이름] 명령으로 서명한 태그 GPG를 사용하여 서명을 검증하므로, 서명자의 GPG 공개키가 필요하며, 없을 경우 에러 메시지를 출력



# 나중에 태그하기

$ git log --pretty=oneline

@ ... 9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile ...

@ 커밋 히스토리를 통하여 예전 커밋에 대해서도 태그

$ git tag -a v1.2 -m 'version 1.2' 9fceb02

@ 특정 커밋에 태그하기 위해서 명령의 끝에 커밋 체크섬을 명시 (긴 체크섬을 전부 사용할 필요는 없음)

$ git tag

@ 만든 태그를 확인



# 태그 공유하기

@ $ git push 명령은 자동으로 리모트 서버에 태그를 전송하지 않으므로, 태그를 만들었으면 서버에 별도로 Push해야 하며 브랜치를 공유하는 것과 같은 방법으로 $ git push origin [태그 이름]을 실행

@ 만약 한 번에 태그를 여러 개 Push하고 싶으면 --tags 옵션을 추가하여 git push명령을 실행 (리모트 서버에 없는 태그를 모두 전송)

@ 누군가 저장소에서 Clone하거나 Pull을 하면 모든 태그 정보도 함께 전송됌







Chapter 3 - Git 브랜치



# branch 만들기

브랜치의 목록을 볼 때

git branch

브랜치를 생성할 때

git branch "새로운 브랜치 이름"

브랜치를 삭제할 때

git branch -d

병합하지 않은 브랜치를 강제 삭제할 때

git branch -D

브랜치를 전환(체크아웃)할 때

git checkout "전환하려는 브랜치 이름"

브랜치를 생성하고 전환까지 할 때

git checkout -b "생성하고 전환할 브랜치 이름"



# branch 정보확인

브랜치 간에 비교할 때

git log "비교할 브랜치 명 1".."비교할 브랜치 명 2"

브랜치 간의 코드를 비교 할 때

git diff "비교할 브랜치 명 1".."비교할 브랜치 명 2"

로그에 모든 브랜치를 표시하고, 그래프로 표현하고, 브랜치 명을 표시하고, 한줄로 표시할 때

git log --branches --graph --decorate --oneline



# branch 병합

A 브랜치로 B 브랜치를 병합할 때 (A ← B)

git checkout A

git merge B



# branch 병합 시 충돌해결

충돌 발생 시 CONFLICT 메시지 출력됌

충돌이 일어난 파일 탐색

$ git status

충돌이 발생한 파일을 아래와 같이 수정

'<<<<<<< HEAD' 부터 '=======' 사이의 구간이 현재 체크 아웃된 파일의 내용이고 '=======' 부터 '>>>>>>> exp' 사시의 구간이 병합하려는 대상인 exp 브랜치의 코드 내용이므로 이 정보를 참고로해서 두개의 코드를 병합한 후에 특수기호들을 제거하고, 작업이 끝나면 파일을 저장

충돌 수정 작업을 끝낸 파일을 추적

$ git add 'conflicted file name'



# stash

다른 브랜치로 checkout을 해야 하는데 아직 현재 브랜치에서 작업이 끝나지 않은 경우는 커밋을 하기가 애매하므로, 이런 경우 stash를 이용하면 작업중이던 파일을 임시로 저장해두고 현재 브랜치의 상태를 마지막 커밋의 상태로 초기화 할 수 있고, 그 후에 다른 브랜치로 이동하고 작업을 끝낸 후에 작업 중이던 브랜치로 복귀한 후에 이전에 작업하던 내용을 복원 가능함

$ git stash save

$ git stash list

아래와 같이 적용(복원)과 stash 목록 삭제를 한번에 가능 $ git stash apply; git stash drop;

$ git stash pop






Chapter 4 - 생활코딩



# 저장소 만들기

프로젝트 파일을 생성

$ mkdir gitfth

프로젝트 디렉토리로 이동

$ cd gitfth

현재 디렉토리를 git의 (버전) 저장소로 지정

$ git init



# git이 관리할 대상으로 파일 등록

파일을 생성

$ vim f1.txt

git이 파일을 추적하도록 명령

$ git add f1.txt

프로젝트 폴더의 상태를 확인

$ git status



# 버전 만들기 (commit)



* 만약 vim이 아니라 nano와 같은 에디터가 실행되면 아래 명령을 사용

$ git config --global core.editor "vim"



버전에 포함될 버전을 만든 사람에 대한 정보를 설정이며, 이 설정은 ~/.gitconfig 파일에 저장되고 최초 1회 실행

$ git config --global user.name "자신의 닉네임"

$ git config --global user.email "자신의 이메일"



# Stage area

git은 commit 전에 add를 꼭해야 하며, 그 이유는 선택적으로 파일을 버전에 포함시키기 위함



# 변경사항 확인하기

로그에서 출력되는 버전 간의 차이점을 출력하고 싶을 때

$ git log -p

버전 간의 차이점을 비교할 때

$ git diff '버전 id'..'버전 id2'

git add하기 전과 add한 후의 파일 내용을 비교할 때

$ git diff



# 과거의 버전으로 돌아가기

아래 명령은 버전 id로 돌아가는 명령

$ git reset --hard "버전 id"

버전 id의 커밋을 취소한 내용을 새로운 버전으로 만드는 명령

$ git revert "버전 id"

reset과 revert의 차이점에 대해서 재미있게 설명하는 카툰

http://www.popit.kr/



# 태그(tag)

태그 목록 보기

git tag

태그 생성 (light weight tag)

git tag "태그 이름" [태그가 가르킬 버전의 커밋 아이디]

태그 생성 (annotated tag)

git tag -a "태그 이름" -m "태그에 대한 설명" [태그가 가르킬 버전의 커밋 아이디]

태그 삭제

git tag -d "삭제할 태그명"

태그 원격 저장소로 업로드

git push --tags

Semantic Versioning
